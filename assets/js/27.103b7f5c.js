(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{198:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"测试覆盖率"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#测试覆盖率","aria-hidden":"true"}},[t._v("#")]),t._v(" 测试覆盖率")]),t._v(" "),e("p",[t._v("主要分为两类，一个是面向项目的需求覆盖率，一个是偏向技术的代码覆盖率")]),t._v(" "),e("h2",{attrs:{id:"需求覆盖率"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#需求覆盖率","aria-hidden":"true"}},[t._v("#")]),t._v(" 需求覆盖率")]),t._v(" "),e("p",[t._v("测试对需求的覆盖程度，将每条分解后的软件需求和对应的测试用例建立一对多的关系，保证测试可以覆盖每个需求。通常采用TestLink、ALM、Doors等等需求管理工具建立需求和测试的对应关系")]),t._v(" "),e("p",[t._v("需求覆盖率统计方法属于传统瀑布模型下的软件工程实践，目前都是将软件的需求转换成测试需求，然后基于测试需求来设计测试点")]),t._v(" "),e("h2",{attrs:{id:"代码覆盖率"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码覆盖率","aria-hidden":"true"}},[t._v("#")]),t._v(" 代码覆盖率")]),t._v(" "),e("p",[t._v("指至少被执行了一次的代码行、函数、路径等等占整个条目数的百分比。常见的代码覆盖率指标有语句覆盖、判定覆盖、条件覆盖")]),t._v(" "),e("p",[t._v("代码覆盖率反应的是已有代码的哪些逻辑被执行了，哪些逻辑还没有被执行过，以此为依据，补充测试用例，去测试那些还没有覆盖到的执行路径")]),t._v(" "),e("h2",{attrs:{id:"代码覆盖率工具"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码覆盖率工具","aria-hidden":"true"}},[t._v("#")]),t._v(" 代码覆盖率工具")]),t._v(" "),e("p",[t._v("java主流的代码覆盖率工具JaCoCo")])])}],!1,null,null,null);a.default=s.exports}}]);