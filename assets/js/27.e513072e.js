(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{169:function(t,v,_){"use strict";_.r(v);var a=_(0),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("div",{staticClass:"content"},[_("h1",{attrs:{id:"代码级测试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代码级测试","aria-hidden":"true"}},[t._v("#")]),t._v(" 代码级测试")]),t._v(" "),_("p",[t._v("代码错误，分为“有特征”的错误和“无特征”的错误。有特征的错误：语法特征错误、边界行为错误、经验特征错误。无特征的错误：算法错误和部分算法错误。")]),t._v(" "),_("p",[t._v("**语法特征错误：**从编程语法上就能发现的错误")]),t._v(" "),_("p",[t._v("**边界行为特征错误：**代码在执行过程中发生异常，崩溃或者超时")]),t._v(" "),_("p",[t._v("**经验特征错误：**根据过往经验发现代码错误")]),t._v(" "),_("p",[t._v("**算法错误：**代码完成的计算（功能）和之前预先设计的计算结果不一致")]),t._v(" "),_("p",[t._v("**部分算法错误：**在一些特定的条件或者输入情况下，算法不能准确完成业务要求实现的功能")]),t._v(" "),_("p",[t._v("代码级测试方法主要分为两大类：静态方法和动态方法")]),t._v(" "),_("p",[t._v("**静态方法：**在不实际执行代码的基础上发现代码缺陷的方法，又可用分为人工静态方法和自动静态方法")]),t._v(" "),_("p",[t._v("**动态方法：**通过实际代码发现代码中潜在缺陷的方法，又可分为动态方法和自动动态方法")]),t._v(" "),_("h4",{attrs:{id:"人工静态方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#人工静态方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 人工静态方法")]),t._v(" "),_("p",[t._v("​\t通过阅读代码查找代码中潜在错误的方法，通常采用的手段有：开发人员代码走查，结对编程，同行评审。")]),t._v(" "),_("p",[t._v("​\t"),_("strong",[t._v("代码走查")]),t._v("，由开发人员检查自己的代码，尽可能多的发现各类潜在错误，但由于个人能力的差异以及开发人员的“思维惯性”，很多错误并不能在这个阶段被及时发现。")]),t._v(" "),_("p",[t._v("​\t"),_("strong",[t._v("结对编程")]),t._v("，一种敏捷软件开发的方法，一般由两个开发人员结成对在一台计算机上共同完成开发任务，其中一个开发人员实现代码，另外一个审查输入的每行代码。")]),t._v(" "),_("p",[t._v("​\t"),_("strong",[t._v("同行评审")]),t._v("，代码递交到代码仓库，或者合并代码分支到主干前，需要和你同技术级别或者更高技术级别的同事对你代码进行评审。如果项目采用github管理代码并采用gitflow的分支管理策略，那么在pull request时，只有经过所有的评审者审核通过才能合并")]),t._v(" "),_("h4",{attrs:{id:"自动静态方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自动静态方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 自动静态方法")]),t._v(" "),_("p",[t._v("​\t不运行代码的方式下，通过词法分析、语法分析、控制流分析等技术，并结合各种预定义和自定义的代码规则，对程序代码进行静态扫描发现语法错误、潜在语义错误，以及部分动态错误的 一种代码分析技术。根据不同的开发语言，选择不同的工具，比如"),_("strong",[t._v("sonar、coverity")])]),t._v(" "),_("p",[t._v("​\t可以发现这些问题：使用未初始化的变量、变量在使用前未定义、变量声明了但未使用、变量类型不匹配、部分的内存泄漏问题、空指针引用、缓冲区溢出、数组越界、不可达的僵尸代码、过高的代码复杂度、死循环、大量的重复代码块")]),t._v(" "),_("h4",{attrs:{id:"人工动态方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#人工动态方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 人工动态方法")]),t._v(" "),_("p",[t._v("​\t设计代码的输入和预期的正确输出的集合，然后执行代码，判断实际输出是否符合预期。人工动态方法是最主要的测试手段，可以真正检测代码的逻辑功能，关注点是“什么样的输入，执行了什么代码，产生了什么样的输出”，所以最善于发现算法的错误和部分算法错误。不同开发语言对应不同的单元测试框架，比如java对应的有Junit和TestNG，c语言对应的有google Test")]),t._v(" "),_("h4",{attrs:{id:"自动动态方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自动动态方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 自动动态方法")]),t._v(" "),_("p",[t._v("​\t基于代码自动生成边界测试用例并执行，以捕捉潜在的异常、崩溃和超时的方法。可以覆盖边界行为特征错误，通常能够发现“忘记处理某些输入”引起的错误")])])}],!1,null,null,null);v.default=r.exports}}]);