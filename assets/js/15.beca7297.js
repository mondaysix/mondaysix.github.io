(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{169:function(a,t,s){"use strict";s.r(t);var e=s(0),n=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"java基础知识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java基础知识","aria-hidden":"true"}},[a._v("#")]),a._v(" java基础知识")]),a._v(" "),s("h2",{attrs:{id:"java反射"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java反射","aria-hidden":"true"}},[a._v("#")]),a._v(" java反射")]),a._v(" "),s("p",[a._v('三种方式得到Class：getClass()、类名.class、Class.forName("")')]),a._v(" "),s("h2",{attrs:{id:"hashmap和hashtable区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap和hashtable区别","aria-hidden":"true"}},[a._v("#")]),a._v(" hashmap和hashtable区别")]),a._v(" "),s("p",[a._v("hashmap继承abstractMap<K,V>，线程不安全,key允许为null,value允许为null。get(object key)方法若返回null，可能是key不存在为null，也可能是key对应的value为null，所以不能通过get方法判断键是否存在，要使用containsKey")]),a._v(" "),s("p",[a._v("hashtable继承Dictionary<K,V>,很多方法加了synchronized，所以是线程安全的。key和value都不允许为null，\nvalue为null抛出nullpointexception")]),a._v(" "),s("h2",{attrs:{id:"string-stringbuffer、stringbuilder区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#string-stringbuffer、stringbuilder区别","aria-hidden":"true"}},[a._v("#")]),a._v(" String Stringbuffer、stringbuilder区别")]),a._v(" "),s("p",[s("strong",[a._v("主要在运行速度和线程安全方面的区别")]),a._v("\n运行速度：stringbuilder > stringbuffer > string\nStringbuffer和stringbuilder继承abstractstringbuilder抽象类\nstring：字符串常量，一旦创建则该对象不可更改，如果不断的进行创建、回收对象，则速度会变慢\nStringbuffer：线程安全，其中的append方法使用了synchoronized，导致效率比stringbuilder低\nstringbuilder：非线程安全，效率高于stringbuffer")]),a._v(" "),s("h2",{attrs:{id:"java-se、ee、me及框架"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-se、ee、me及框架","aria-hidden":"true"}},[a._v("#")]),a._v(" java SE、EE、ME及框架")]),a._v(" "),s("p",[a._v("SE：standard edition\nEE：enterprise edition\nME：micro edition\n框架：Struts、Spring、Hibernate、spring mvc，spring boot, spring cloud、mybatis")]),a._v(" "),s("h2",{attrs:{id:"java多线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java多线程","aria-hidden":"true"}},[a._v("#")]),a._v(" Java多线程")]),a._v(" "),s("p",[a._v("线程池")]),a._v(" "),s("p",[a._v("​\t原理：提交一个任务到线程池中，流程如下")]),a._v(" "),s("p",[a._v("​\t\t第一步：先判断线程池的核心线程是否都在执行任务，若不满，则创建，若核心线程都在执行任务，看第二步\n​\t\t第二步：线程池判断工作队列是否已满，若没有满，则将新提交的存储在工作队列里，若满了，看第三步\n​\t\t第三步：判断线程池里的线程是否都处于工作状态，若没有，则创建新工作线程执行任务，若满了，交给饱和策略来进行处理\n​\t线程是稀缺资源，被无限制的创建，不仅消耗系统资源还会降低系统稳定性。所以要创建线程池")]),a._v(" "),s("p",[s("strong",[a._v("创建线程池核心参数")])]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LinkedBlockingDeque")]),a._v(" queque "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LinkedBlockingDeque")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Runnable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("RejectedExecutionHandler")]),a._v(" handler "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ThreadPoolExecutor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("DiscardPolicy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//饱和策略")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ThreadPoolExecutor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("60")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("TimeUnit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("SECONDS"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("queque"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("handler"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//核心线程数2个，全部线程数10个，工作队列3个")]),a._v("\ncorePoolSize：核心线程数，当提交任务，线程池创建新线程执行任务直到当前线程数等于corePoolSize\nmaximumPoolSize：线程池中允许的最大线程数，若当前阻塞队列满了，继续提交任务，创建新的线程执行任务，前提是小于maximum\nkeepAliveTime：线程空闲时的存活时间\nunit：keepaliveTime的单位\nworkQueue：用来保存等待被执行的任务的阻塞队列，且实现runnable接口\n")])])]),s("h3",{attrs:{id:"线程的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程的生命周期","aria-hidden":"true"}},[a._v("#")]),a._v(" 线程的生命周期")]),a._v(" "),s("p",[a._v("周期：NEW(新建)、RUNNABLE（就绪）、RUNNING（运行）、BLOCKED（阻塞）、DEAD（死亡）\n僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中")]),a._v(" "),s("h3",{attrs:{id:"线程安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程安全","aria-hidden":"true"}},[a._v("#")]),a._v(" 线程安全")]),a._v(" "),s("p",[a._v("实现线程安全的方式有：同步代码块、同步方法、加lock锁机制\nwait()和sleep()最大的不同在于wait()会释放对象锁，而sleep()不会释放对象锁。")]),a._v(" "),s("p",[s("strong",[a._v("synchronized、volatile区别")])]),a._v(" "),s("p",[a._v("synchronized锁粒度、模拟死锁场景、原子性与可见性；\nvolatile强制线程每次从主内存中读到变量，而不是从线程的私有内存中读取变量，保证数据的可见性\nvolatile轻量级，只修饰变量，不能同步\nsynchronized重量级，可以用来修饰方法，保证可见性和原子性")])])}],!1,null,null,null);t.default=n.exports}}]);