(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{182:function(e,t,n){"use strict";n.r(t);var v=n(0),i=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"android-知识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#android-知识","aria-hidden":"true"}},[e._v("#")]),e._v(" Android 知识")]),e._v(" "),n("h2",{attrs:{id:"四大组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四大组件","aria-hidden":"true"}},[e._v("#")]),e._v(" 四大组件")]),e._v(" "),n("blockquote",[n("p",[n("strong",[e._v("Activity")])])]),e._v(" "),n("p",[n("strong",[e._v("生命周期")]),e._v("：onCreate()--\x3eonStart()--\x3eonResume()--\x3eonPause()--\x3eonStop()---\x3eonRestart()--\x3eonDestroy()")]),e._v(" "),n("p",[e._v("启动Activity：onCreate()--\x3eonStart()--\x3eonResume()然后Activity进入运行状态")]),e._v(" "),n("p",[e._v("当前Activity被其他Activity覆盖,调用onPause()")]),e._v(" "),n("p",[e._v("当前ACTIVITY回到前台，调用OnResume")]),e._v(" "),n("p",[n("strong",[e._v("启动模式")])]),e._v(" "),n("p",[e._v("Standard（每次都会创建一个activity）、")]),e._v(" "),n("p",[e._v("singleTop（栈顶复用）：若需要创建的activity处于栈顶，则直接复用，onNewIntent（传入新的intent）会被调用。如果没有处于栈顶则和standard模式一致")]),e._v(" "),n("p",[e._v("singleTask(栈内复用)：若需要创建的activity处于栈内，则把存在他上面的所有activity都销毁")]),e._v(" "),n("p",[e._v("singleInstance(全局单例模式)：整个系统中只有一个")]),e._v(" "),n("p",[e._v("启动模式方式：")]),e._v(" "),n("p",[e._v("​       manifest.xml中静态指定，launchMode")]),e._v(" "),n("pre",[n("code",[e._v("intent中动态指定：addFlags\n")])]),e._v(" "),n("blockquote",[n("p",[n("strong",[e._v("Service")])])]),e._v(" "),n("p",[e._v("启动方式：startservice和bindservice")]),e._v(" "),n("p",[e._v("**startservice：**启动一个服务执行后台任务，不进行通信，停止服务使用stopservice")]),e._v(" "),n("p",[e._v("生命周期：startservice—>oncreate---\x3eonstartcommand---\x3eservice running—>ondestroy")]),e._v(" "),n("p",[e._v("**bindservice:**启动服务可以进行通信，停止服务使用unbindservice")]),e._v(" "),n("p",[e._v("生命周期：bindservice---》oncreate---》onbind---》client are bound to service---》onunbind---》ondestroy")]),e._v(" "),n("p",[e._v("service需要注册在manifest")]),e._v(" "),n("p",[e._v("两者的区别：startservice与客户端是否退出没有关联关系，即使客户端停止运行，服务同样也会在后台运行。bindservice是与客户端绑定的，客户端退出，service也自动停止")]),e._v(" "),n("p",[n("strong",[e._v("BroadcastReceiver")])]),e._v(" "),n("p",[e._v("静态注册和动态注册")]),e._v(" "),n("p",[n("strong",[e._v("ContentProvider")])]),e._v(" "),n("h2",{attrs:{id:"aidl"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aidl","aria-hidden":"true"}},[e._v("#")]),e._v(" AIDL")]),e._v(" "),n("p",[e._v("Android Interface Definition Language，接口定义语言，"),n("strong",[e._v("为了实现进程间的通信")])]),e._v(" "),n("p",[e._v("每个进程都由自己的Dalvik VM实例，一块独立的内存，存储自己的数据，执行自己的操作。不同的进程不知道相互的信息，则出现了AIDL，通过AIDL制定一些规则，规定它们能进行哪些操作，一个进程可以访问另外一个进程的数据")]),e._v(" "),n("p",[e._v("数据类实现Parcelable接口，将需要传输的数据转化为能够在内存之间流通的形式，即序列化与反序列化")])])}],!1,null,null,null);t.default=i.exports}}]);